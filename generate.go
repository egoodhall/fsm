package fsm

import (
	"fmt"

	"github.com/dave/jennifer/jen"
)

func Generate(pkg string, model *FsmModel) *jen.File {
	file := jen.NewFile(pkg)
	file.PackageComment("Generated by fsmgen. DO NOT EDIT.")

	// Public interfaces
	for _, c := range generatePublicInterfaces(model) {
		file.Add(c).Line()
	}

	file.Comment("FSM type checks")
	file.Var().Id("_").Id(model.FsmName()).Op("=").New(jen.Id(model.FsmInternalName()))
	file.Var().Id("_").Qual("github.com/egoodhall/fsm", "SupportsOptions").Op("=").New(jen.Id(model.FsmInternalName()))
	for _, state := range model.States {
		if !state.Terminal {
			file.Var().Id("_").Id(model.FsmBuilderStageName(state)).Op("=").New(jen.Id(model.FsmInternalName()))
		}
	}
	file.Var().Id("_").Id(model.FsmBuilderFinalStageName()).Op("=").New(jen.Id(model.FsmInternalName()))
	for _, state := range model.States {
		if !state.Terminal {
			file.Var().Id("_").Id(model.TransitionsParamTypeName(state)).Op("=").New(jen.Id(model.FsmInternalName()))
		}
	}

	file.Line().Commentf("%s implementation", model.FsmName())

	// FSM implementation
	for _, c := range generateFSMImplementation(model) {
		file.Add(c).Line()
	}

	return file
}

func generatePublicInterfaces(model *FsmModel) []jen.Code {
	code := make([]jen.Code, 0)

	code = append(code, jen.Type().Id(model.StateTypeName()).Qual("github.com/egoodhall/fsm", "State"))

	code = append(code, jen.Const().DefsFunc(func(g *jen.Group) {
		for _, state := range model.States {
			g.Id(model.StateName(state)).Id(model.StateTypeName()).Op("=").Lit(string(state.Name))
		}
	}))

	// FSM interface
	code = append(code, jen.Type().Id(model.FsmName()).Interface(
		jen.Qual("github.com/egoodhall/fsm", "SupportsOptions"),
		jen.Id("Submit").
			ParamsFunc(func(g *jen.Group) {
				g.Id("ctx").Qual("context", "Context")
				for _, param := range model.InitialState().Inputs {
					g.Id(param).Add(model.RenderType(param))
				}
			}).
			Params(jen.Qual("github.com/egoodhall/fsm", "TaskID"), jen.Error()),
	))

	// FSM builder constructor
	code = append(code, jen.Func().Id(model.FsmBuilderConstructorName()).Params().
		Id(model.FsmBuilderStageName(model.InitialState())).Block(
		jen.Return(jen.New(jen.Id(model.FsmInternalName()))),
	))

	// FSM transition interfaces
	for _, state := range model.States {
		if state.Terminal {
			continue
		}

		code = append(code, jen.Type().Id(model.TransitionsParamTypeName(state)).InterfaceFunc(func(g *jen.Group) {
			for _, transition := range state.Transitions {
				params := []jen.Code{jen.Qual("context", "Context")}
				for _, param := range model.GetState(transition).Inputs {
					params = append(params, model.RenderType(param))
				}
				g.Id(model.TransitionToName(transition)).Params(params...).Error()
			}
		}))
	}

	// FSM builder stage interfaces
	for i, state := range model.States {
		method := jen.Id(model.FsmBuilderStageMethodName(state)).Params(
			generateFSMStateMethodSignature(model, state),
		)
		if next, ok := nextNonTerminalState(model.States[i+1:]); ok {
			method = method.Id(model.FsmBuilderStageName(next))
		} else {
			method = method.Id(model.FsmBuilderFinalStageName())
		}

		code = append(code, jen.Type().Id(model.FsmBuilderStageName(state)).Interface(method).Line())
	}

	// FSM builder final stage
	code = append(code, jen.Type().Id(model.FsmBuilderName()+"__FinalStage").Interface(
		jen.Id("BuildAndStart").Params(jen.Qual("context", "Context"), jen.Op("...").Qual("github.com/egoodhall/fsm", "Option")).Params(jen.Id(model.FsmName()), jen.Error()),
	))

	return code
}

func nextNonTerminalState(states []StateModel) (StateModel, bool) {
	for _, state := range states {
		if state.Terminal {
			continue
		}
		return state, true
	}
	return StateModel{}, false
}

func generateFSMImplementation(model *FsmModel) []jen.Code {
	code := make([]jen.Code, 0)

	// State transition messages
	for _, state := range model.States {
		code = append(code, jen.Type().Id(model.FsmStateMessageName(state)).StructFunc(func(g *jen.Group) {
			g.Id("ID").Qual("github.com/egoodhall/fsm", "TaskID")
			g.Id("Attempt").Int()
			for i, input := range state.Inputs {
				g.Id(fmt.Sprintf("P%d", i)).Add(model.RenderType(input))
			}
		}))
	}

	// FSM struct
	code = append(code,
		jen.Type().Id(model.FsmInternalName()).StructFunc(func(g *jen.Group) {
			g.Id("lock").Qual("sync", "Mutex")
			g.Id("ctx").Qual("context", "Context")
			g.Line()
			g.Comment("Configuration options")
			g.Id("store").Qual("github.com/egoodhall/fsm", "Store")
			g.Id("onTransition").Qual("github.com/egoodhall/fsm", "TransitionListener")
			g.Id("onCompletion").Qual("github.com/egoodhall/fsm", "CompletionListener")
			g.Id("backoff").Qual("github.com/egoodhall/fsm", "Backoff")
			g.Line()
			g.Comment("FSM state transitions")
			for _, state := range model.States {
				if state.Terminal {
					continue
				}
				g.Id(model.FsmStateInternalName(state)).Add(generateFSMStateMethodSignature(model, state))
			}
			g.Line()
			g.Comment("FSM queues")
			for _, state := range model.States {
				g.Id(model.FsmStateQueueInternalName(state)).Chan().Id(model.FsmStateMessageName(state))
			}
		}),
		jen.Comment("FSM builder methods"),
	)

	// FSM builder stage methods
	for i, state := range model.States {
		if state.Terminal {
			// No transitions from terminal states
			continue
		}

		method := jen.Func().
			Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
			Id(model.FsmBuilderStageMethodName(state)).Params(
			jen.Id("fn").Add(generateFSMStateMethodSignature(model, state)),
		)

		if next, ok := nextNonTerminalState(model.States[i+1:]); ok {
			method = method.Id(model.FsmBuilderStageName(next))
		} else {
			method = method.Id(model.FsmBuilderFinalStageName())
		}

		code = append(code,
			method.Block(
				jen.Id("f").Dot(model.FsmStateInternalName(state)).Op("=").Id("fn"),
				jen.Return(jen.Id("f")),
			),
		)
	}

	// FSM builder final stage
	code = append(code,
		jen.Func().
			Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
			Id("BuildAndStart").
			Params(jen.Id("ctx").Qual("context", "Context"), jen.Id("opts").Op("...").Qual("github.com/egoodhall/fsm", "Option")).
			Params(jen.Id(model.FsmName()), jen.Error()).
			BlockFunc(func(g *jen.Group) {
				// Check if FSM is already started
				g.Comment("Check if FSM is already started")
				g.If(jen.Op("!").Id("f").Dot("lock").Dot("TryLock").Call()).Block(
					jen.Return(jen.Nil(), jen.Qual("errors", "New").Call(jen.Lit("FSM already started"))),
				)
				g.Line()
				g.Comment("Set context")
				g.Id("f").Dot("ctx").Op("=").Id("ctx")
				g.Line()
				g.Comment("Initialize state queues")
				for _, state := range model.States {
					g.Id("f").Dot(model.FsmStateQueueInternalName(state)).Op("=").Make(jen.Chan().Id(model.FsmStateMessageName(state)), jen.Lit(max(state.Queue, 5)))
				}
				g.Line()
				// Apply options
				g.Comment("Apply options")
				g.For(jen.List(jen.Id("_"), jen.Id("opt")).Op(":=").Range().Id("opts")).Block(
					jen.If(jen.Err().Op(":=").Id("opt").Call(jen.Id("f")), jen.Err().Op("!=").Nil()).Block(
						jen.Return(jen.Nil(), jen.Err()),
					),
				)
				g.If(jen.Id("f").Dot("store").Op("==").Nil()).Block(
					jen.If(jen.List(jen.Id("store"), jen.Err()).Op(":=").Qual("github.com/egoodhall/fsm", "InMemory").Call().Call(), jen.Err().Op("!=").Nil()).Block(
						jen.Return(jen.Nil(), jen.Err()),
					).Else().Block(
						jen.Id("f").Dot("store").Op("=").Id("store"),
					),
				)
				g.If(jen.Id("f").Dot("backoff").Op("==").Nil()).Block(
					jen.Id("f").Dot("backoff").Op("=").Qual("github.com/egoodhall/fsm", "LinearBackoff").Call(jen.Lit(500).Op("*").Qual("time", "Millisecond"), jen.Lit(30).Op("*").Qual("time", "Second")),
				)
				g.Line()
				// Start FSM processors
				g.Comment("Start FSM processors")
				for _, state := range model.States {
					g.Commentf("Start %d %s processors", state.Workers, model.FsmStateProcessorName(state))
					if state.Workers == 1 {
						g.Go().Id("f").Dot(model.FsmStateProcessorName(state)).Call()
					} else {
						g.For(jen.Id("i").Op(":=").Lit(0), jen.Id("i").Op("<").Lit(state.Workers), jen.Id("i").Op("++")).Block(
							g.Go().Id("f").Dot(model.FsmStateProcessorName(state)).Call(),
						)
					}
				}
				g.Line()
				// Resume tasks
				g.Comment("Resume existingtasks")
				g.If(jen.Err().Op(":=").Id("f").Dot("resumeTasks").Call(jen.Id("ctx")), jen.Err().Op("!=").Nil()).Block(
					jen.Return(jen.Nil(), jen.Err()),
				)
				// Return FSM
				g.Return(jen.Id("f"), jen.Nil())
			}),
	)

	// Resume tasks
	code = append(code,
		jen.Func().Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
			Id("resumeTasks").
			Params(jen.Id("ctx").Qual("context", "Context")).
			Error().
			Block(
				jen.List(jen.Id("tasks"), jen.Err()).Op(":=").Id("f").Dot("store").Dot("Q").Call().Dot("ListTasks").Call(jen.Id("ctx")),
				jen.If(jen.Err().Op("!=").Nil()).Block(
					jen.Return(jen.Err()),
				),
				jen.For(jen.List(jen.Id("_"), jen.Id("task")).Op(":=").Range().Id("tasks")).BlockFunc(func(g *jen.Group) {
					g.List(jen.Id("transition"), jen.Err()).Op(":=").Id("f").Dot("store").Dot("Q").Call().Dot("GetLastValidTransition").Call(jen.Id("ctx"), jen.Id("task").Dot("ID"))
					g.If(jen.Err().Op("!=").Nil()).Block(
						jen.Return(jen.Err()),
					)
					g.Line()
					g.Switch(jen.Id(model.StateTypeName()).Call(jen.Id("transition").Dot("ToState"))).BlockFunc(func(g *jen.Group) {
						for _, state := range model.States {
							if state.Terminal {
								continue
							}
							g.Case(jen.Id(model.StateName(state))).Block(
								jen.Var().Id("msg").Id(model.FsmStateMessageName(state)),
								jen.If(jen.Err().Op(":=").Qual("encoding/gob", "NewDecoder").Call(jen.Qual("bytes", "NewReader").Call(jen.Id("task").Dot("Data"))).Dot("Decode").Call(jen.Op("&").Id("msg")), jen.Err().Op("!=").Nil()).Block(
									jen.Return(jen.Err()),
								),
								jen.Qual("github.com/egoodhall/fsm", "Logger").Call(jen.Id("ctx")).Dot("Info").Call(jen.Lit("Resuming task"), jen.Lit("id"), jen.Id("task").Dot("ID")),
								jen.Select().Block(
									jen.Case(jen.Id("f").Dot(model.FsmStateQueueInternalName(state)).Op("<-").Id("msg")).Block(
										jen.Return(jen.Nil()),
									),
									jen.Case(jen.Op("<-").Id("ctx").Dot("Done").Call()).Block(
										jen.Return(jen.Qual("errors", "New").Call(jen.Lit("task submission cancelled"))),
									),
								),
							)
						}
					})
				}),
				jen.Return(jen.Nil()),
			),
	)

	// FSM option methods
	code = append(code,
		jen.Comment("FSM options"),
		jen.Func().
			Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
			Id("WithStore").
			Params(jen.Id("store").Qual("github.com/egoodhall/fsm", "Store")).
			Block(
				jen.Id("f").Dot("store").Op("=").Id("store"),
			),
		jen.Func().
			Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
			Id("WithContext").
			Params(jen.Id("update").Func().Params(jen.Qual("context", "Context")).Qual("context", "Context")).
			Block(
				jen.Id("f").Dot("ctx").Op("=").Id("update").Call(jen.Id("f").Dot("ctx")),
			),
		jen.Func().
			Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
			Id("WithTransitionListener").
			Params(jen.Id("listener").Qual("github.com/egoodhall/fsm", "TransitionListener")).
			Block(
				jen.Id("f").Dot("onTransition").Op("=").Id("listener"),
			),
		jen.Func().
			Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
			Id("WithCompletionListener").
			Params(jen.Id("listener").Qual("github.com/egoodhall/fsm", "CompletionListener")).
			Block(
				jen.Id("f").Dot("onCompletion").Op("=").Id("listener"),
			),
		jen.Func().
			Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
			Id("WithBackoff").
			Params(jen.Id("backoff").Qual("github.com/egoodhall/fsm", "Backoff")).
			Block(
				jen.Id("f").Dot("backoff").Op("=").Id("backoff"),
			),
	)

	// FSM transition methods
	code = append(code, jen.Comment("FSM transition methods"))
	for _, state := range model.States {
		code = append(code,
			jen.Func().
				Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
				Id(model.TransitionToName(state.Name)).
				ParamsFunc(func(g *jen.Group) {
					g.Id("ctx").Qual("context", "Context")
					for i, param := range state.Inputs {
						g.Id(fmt.Sprintf("P%d", i)).Add(model.RenderType(param))
					}
				}).
				Error().
				Block(
					jen.Id("id").Op(":=").Qual("github.com/egoodhall/fsm", "GetTaskID").Call(jen.Id("ctx")),
					jen.Id("fromState").Op(":=").Qual("github.com/egoodhall/fsm", "GetState").Call(jen.Id("ctx")),
					jen.Id("toState").Op(":=").Qual("github.com/egoodhall/fsm", "State").Call(jen.Id(model.StateName(state))),
					jen.Id("msg").Op(":=").Id(model.FsmStateMessageName(state)).ValuesFunc(func(g *jen.Group) {
						g.Id("ID").Op(":").Id("id")
						for i := range state.Inputs {
							g.Id(fmt.Sprintf("P%d", i)).Op(":").Id(fmt.Sprintf("P%d", i))
						}
					}),
					jen.Line(),
					// Encode and save transition
					jen.Id("buf").Op(":=").New(jen.Qual("bytes", "Buffer")),
					jen.If(jen.Err().Op(":=").Qual("encoding/gob", "NewEncoder").Call(jen.Id("buf")).Dot("Encode").Call(jen.Id("msg")), jen.Err().Op("!=").Nil()).Block(
						jen.Return(jen.Err()),
					),
					jen.Line(),
					jen.If(jen.Err().Op(":=").Id("f").Dot("store").Dot("Q").Call().Dot("RecordTransition").Call(
						jen.Id("ctx"),
						jen.Qual("github.com/egoodhall/fsm/gen/sqlc", "RecordTransitionParams").ValuesFunc(func(g *jen.Group) {
							g.Line().Id("TaskID").Op(":").Int64().Call(jen.Id("id"))
							g.Line().Id("Attempt").Op(":").Int64().Call(jen.Qual("github.com/egoodhall/fsm", "GetAttempt").Call(jen.Id("ctx")))
							g.Line().Id("FromState").Op(":").String().Call(jen.Id("fromState"))
							g.Line().Id("ToState").Op(":").String().Call(jen.Id("toState"))
							g.Line().Id("Data").Op(":").Id("buf").Dot("Bytes").Call()
							g.Line()
						}),
					), jen.Err().Op("!=").Nil()).Block(
						jen.Return(jen.Err()),
					),
					jen.Qual("github.com/egoodhall/fsm", "Logger").Call(jen.Id("ctx")).Dot("Debug").Call(jen.Lit("Transitioned state"), jen.Lit("id"), jen.Id("id"), jen.Lit("from"), jen.Id("fromState"), jen.Lit("to"), jen.Id("toState")),
					jen.If(jen.Id("f").Dot("onTransition").Op("!=").Nil()).Block(
						jen.Id("f").Dot("onTransition").Call(jen.Id("ctx"), jen.Id("msg").Dot("ID"), jen.Id("fromState"), jen.Id("toState")),
					),
					jen.Line(),
					jen.Select().Block(
						jen.Case(jen.Id("f").Dot(model.FsmStateQueueInternalName(state)).Op("<-").Id("msg")).Block(
							jen.Return(jen.Nil()),
						),
						jen.Case(jen.Op("<-").Id("ctx").Dot("Done").Call()).Block(
							jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("task submission cancelled: id = %d"), jen.Id("id"))),
						),
					),
				),
		)
	}

	// FSM processing methods
	for _, state := range model.States {
		code = append(code,
			jen.Func().
				Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
				Id(model.FsmStateProcessorName(state)).
				Params().
				Block(
					jen.Id("ctx").Op(":=").Qual("github.com/egoodhall/fsm", "PutState").Call(jen.Id("f").Dot("ctx"), jen.Qual("github.com/egoodhall/fsm", "State").Call(jen.Id(model.StateName(state)))),
					jen.For(jen.Id("msg").Op(":=").Range().Id("f").Dot(model.FsmStateQueueInternalName(state))).BlockFunc(func(g *jen.Group) {
						if state.Terminal {
							g.If(jen.Id("f").Dot("onCompletion").Op("!=").Nil()).Block(
								jen.Id("f").Dot("onCompletion").Call(jen.Id("ctx"), jen.Id("msg").Dot("ID"), jen.Qual("github.com/egoodhall/fsm", "State").Call(jen.Id(model.StateName(state)))),
							)
						} else {
							g.Id("ctx2").Op(":=").Qual("github.com/egoodhall/fsm", "PutAttempt").Call(jen.Id("ctx"), jen.Id("msg").Dot("Attempt"))
							g.Qual("github.com/egoodhall/fsm", "Logger").Call(jen.Id("ctx2")).Dot("Debug").Call(jen.Lit("Processing message"), jen.Lit("id"), jen.Id("msg").Dot("ID"), jen.Lit("attempt"), jen.Id("msg").Dot("Attempt"), jen.Lit("state"), jen.Id(model.StateName(state)))
							g.If(jen.Err().Op(":=").Id("f").Dot(model.FsmStateInternalName(state)).CallFunc(func(g *jen.Group) {
								g.Qual("github.com/egoodhall/fsm", "PutTaskID").Call(jen.Id("ctx2"), jen.Id("msg").Dot("ID"))
								if !state.Terminal {
									g.Id("f")
								}
								for i := range state.Inputs {
									g.Id("msg").Dot(fmt.Sprintf("P%d", i))
								}
							}), jen.Err().Op("!=").Nil()).Block(
								jen.Id("msg").Dot("Attempt").Op("++"),
								jen.Id("delay").Op(":=").Id("f").Dot("backoff").Call(jen.Id("msg").Dot("Attempt")),
								jen.Qual("github.com/egoodhall/fsm", "Logger").Call(jen.Id("ctx")).Dot("Debug").Call(jen.Lit("Processing error"), jen.Lit("id"), jen.Id("msg").Dot("ID"), jen.Lit("attempt"), jen.Id("msg").Dot("Attempt"), jen.Lit("delay"), jen.Id("delay"), jen.Lit("state"), jen.Id(model.StateName(state)), jen.Lit("error"), jen.Err()),
								jen.If(jen.Err().Op(":=").Id("f").Dot("store").Dot("Q").Call().Dot("RecordTransition").Call(
									jen.Id("ctx2"),
									jen.Qual("github.com/egoodhall/fsm/gen/sqlc", "RecordTransitionParams").ValuesFunc(func(g *jen.Group) {
										g.Line().Id("TaskID").Op(":").Int64().Call(jen.Id("msg").Dot("ID"))
										g.Line().Id("Attempt").Op(":").Int64().Call(jen.Id("msg").Dot("Attempt"))
										g.Line().Id("FromState").Op(":").String().Call(jen.Id(model.StateName(state)))
										g.Line().Id("ToState").Op(":").String().Call(jen.Qual("github.com/egoodhall/fsm", "StateError"))
										g.Line().Id("Data").Op(":").Id("[]byte").Call(jen.Id("err").Dot("Error").Call())
										g.Line()
									}),
								), jen.Err().Op("!=").Nil()).Block(
									jen.Qual("github.com/egoodhall/fsm", "Logger").Call(jen.Id("ctx")).Dot("Debug").Call(jen.Lit("Failed to record transition"), jen.Lit("id"), jen.Id("msg").Dot("ID"), jen.Lit("attempt"), jen.Id("msg").Dot("Attempt"), jen.Lit("delay"), jen.Id("delay"), jen.Lit("state"), jen.Id(model.StateName(state)), jen.Lit("error"), jen.Err()),
								),
								jen.Line(),
								jen.Go().Func().Params().Block(
									jen.Op("<-").Qual("time", "After").Call(jen.Id("delay")),
									jen.Select().Block(
										jen.Case(jen.Id("f").Dot(model.FsmStateQueueInternalName(state)).Op("<-").Id("msg")).Block(),
										jen.Case(jen.Op("<-").Id("ctx").Dot("Done").Call()).Block(),
									),
								).Call(),
							)
						}
					}),
				),
		)
	}

	// FSM submit method
	code = append(code,
		jen.Comment("Submit FSM tasks"),
		jen.Func().
			Params(jen.Id("f").Op("*").Id(model.FsmInternalName())).
			Id("Submit").
			ParamsFunc(func(g *jen.Group) {
				g.Id("ctx").Qual("context", "Context")
				for i, param := range model.InitialState().Inputs {
					g.Id(fmt.Sprintf("P%d", i)).Add(model.RenderType(param))
				}
			}).
			Params(jen.Qual("github.com/egoodhall/fsm", "TaskID"), jen.Error()).
			Block(
				// Construct message without ID
				jen.Id("msg").Op(":=").Id(model.FsmStateMessageName(model.InitialState())).ValuesFunc(func(g *jen.Group) {
					for i := range model.InitialState().Inputs {
						g.Id(fmt.Sprintf("P%d", i)).Op(":").Id(fmt.Sprintf("P%d", i))
					}
				}),
				jen.Line(),
				// Encode and create task
				jen.Id("buf").Op(":=").New(jen.Qual("bytes", "Buffer")),
				jen.If(jen.Err().Op(":=").Qual("encoding/gob", "NewEncoder").Call(jen.Id("buf")).Dot("Encode").Call(jen.Id("msg")), jen.Err().Op("!=").Nil()).Block(
					jen.Return(jen.Lit(0), jen.Err()),
				),
				jen.Line(),
				jen.List(jen.Id("task"), jen.Err()).Op(":=").Id("f").Dot("store").Dot("Q").Call().Dot("CreateTask").Call(jen.Id("ctx"), jen.Id("buf").Dot("Bytes").Call()),
				jen.If(jen.Err().Op("!=").Nil()).Block(
					jen.Return(jen.Lit(0), jen.Err()),
				),
				jen.Id("msg").Dot("ID").Op("=").Qual("github.com/egoodhall/fsm", "TaskID").Call(jen.Id("task").Dot("ID")),
				jen.Line(),
				jen.Select().Block(
					jen.Case(jen.Id("f").Dot(model.FsmStateQueueInternalName(model.InitialState())).Op("<-").Id("msg")).Block(
						jen.Return(jen.Id("msg").Dot("ID"), jen.Nil()),
					),
					jen.Case(jen.Op("<-").Id("ctx").Dot("Done").Call()).Block(
						jen.Return(jen.Lit(0), jen.Qual("errors", "New").Call(jen.Lit("task submission cancelled"))),
					),
				),
			),
	)

	return code
}

func generateFSMStateMethodSignature(model *FsmModel, state StateModel) jen.Code {
	params := []jen.Code{
		jen.Qual("context", "Context"),
	}
	if !state.Terminal {
		params = append(params, jen.Id(model.TransitionsParamTypeName(state)))
	}
	for _, param := range state.Inputs {
		params = append(params, model.RenderType(param))
	}
	return jen.Func().Params(params...).Error()
}
