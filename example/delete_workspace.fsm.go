// Generated by fsmgen. DO NOT EDIT.
package example

import (
	"bytes"
	"context"
	"encoding/gob"
	"errors"
	"fmt"
	fsm "github.com/egoodhall/fsm"
	"sync"
)

type DeleteWorkspaceState fsm.State

const (
	DeleteWorkspaceStateDeleteRecord DeleteWorkspaceState = "DeleteRecord"
	DeleteWorkspaceStateDeleteRepo   DeleteWorkspaceState = "DeleteRepo"
	DeleteWorkspaceStateDone         DeleteWorkspaceState = "Done"
	DeleteWorkspaceStateError        DeleteWorkspaceState = "Error"
)

type DeleteWorkspaceFSM interface {
	fsm.SupportsOptions
	Submit(ctx context.Context, WorkspaceContext WorkspaceContext) (fsm.TaskID, error)
}

func NewDeleteWorkspaceFSMBuilder() DeleteWorkspaceFSMBuilder_DeleteRecordStage {
	return new(deleteWorkspaceFSM)
}

type DeleteRecordTransitions interface {
	ToDeleteRepo(context.Context, WorkspaceContext, WorkspaceID) error
	ToError(context.Context) error
}

type DeleteRepoTransitions interface {
	ToDone(context.Context) error
	ToError(context.Context) error
}

type DeleteWorkspaceFSMBuilder_DeleteRecordStage interface {
	DeleteRecordState(func(context.Context, DeleteRecordTransitions, WorkspaceContext) error) DeleteWorkspaceFSMBuilder_DeleteRepoStage
}

type DeleteWorkspaceFSMBuilder_DeleteRepoStage interface {
	DeleteRepoState(func(context.Context, DeleteRepoTransitions, WorkspaceContext, WorkspaceID) error) DeleteWorkspaceFSMBuilder__FinalStage
}

type DeleteWorkspaceFSMBuilder_DoneStage interface {
	DoneState(func(context.Context) error) DeleteWorkspaceFSMBuilder__FinalStage
}

type DeleteWorkspaceFSMBuilder_ErrorStage interface {
	ErrorState(func(context.Context) error) DeleteWorkspaceFSMBuilder__FinalStage
}

type DeleteWorkspaceFSMBuilder__FinalStage interface {
	BuildAndStart(context.Context, ...fsm.Option) (DeleteWorkspaceFSM, error)
}

// FSM type checks
var _ DeleteWorkspaceFSM = new(deleteWorkspaceFSM)
var _ fsm.SupportsOptions = new(deleteWorkspaceFSM)
var _ DeleteWorkspaceFSMBuilder_DeleteRecordStage = new(deleteWorkspaceFSM)
var _ DeleteWorkspaceFSMBuilder_DeleteRepoStage = new(deleteWorkspaceFSM)
var _ DeleteWorkspaceFSMBuilder__FinalStage = new(deleteWorkspaceFSM)
var _ DeleteRecordTransitions = new(deleteWorkspaceFSM)
var _ DeleteRepoTransitions = new(deleteWorkspaceFSM)

// DeleteWorkspaceFSM implementation
type deleteWorkspaceFSM_DeleteRecordParams struct {
	ID      fsm.TaskID
	Attempt int
	P0      WorkspaceContext
}

type deleteWorkspaceFSM_DeleteRepoParams struct {
	ID      fsm.TaskID
	Attempt int
	P0      WorkspaceContext
	P1      WorkspaceID
}

type deleteWorkspaceFSM_DoneParams struct {
	ID      fsm.TaskID
	Attempt int
}

type deleteWorkspaceFSM_ErrorParams struct {
	ID      fsm.TaskID
	Attempt int
}

type deleteWorkspaceFSM struct {
	lock sync.Mutex
	ctx  context.Context

	// Configuration options
	store        fsm.Store
	onTransition fsm.TransitionListener
	onCompletion fsm.CompletionListener

	// FSM state transitions
	deleteRecordState func(context.Context, DeleteRecordTransitions, WorkspaceContext) error
	deleteRepoState   func(context.Context, DeleteRepoTransitions, WorkspaceContext, WorkspaceID) error

	// FSM queues
	deleteRecordQueue chan deleteWorkspaceFSM_DeleteRecordParams
	deleteRepoQueue   chan deleteWorkspaceFSM_DeleteRepoParams
	doneQueue         chan deleteWorkspaceFSM_DoneParams
	errorQueue        chan deleteWorkspaceFSM_ErrorParams
}

// FSM builder methods

func (f *deleteWorkspaceFSM) DeleteRecordState(fn func(context.Context, DeleteRecordTransitions, WorkspaceContext) error) DeleteWorkspaceFSMBuilder_DeleteRepoStage {
	f.deleteRecordQueue = make(chan deleteWorkspaceFSM_DeleteRecordParams, 0)
	f.deleteRecordState = fn
	return f
}

func (f *deleteWorkspaceFSM) DeleteRepoState(fn func(context.Context, DeleteRepoTransitions, WorkspaceContext, WorkspaceID) error) DeleteWorkspaceFSMBuilder__FinalStage {
	f.deleteRepoQueue = make(chan deleteWorkspaceFSM_DeleteRepoParams, 0)
	f.deleteRepoState = fn
	return f
}

func (f *deleteWorkspaceFSM) BuildAndStart(ctx context.Context, opts ...fsm.Option) (DeleteWorkspaceFSM, error) {
	// Check if FSM is already started
	if !f.lock.TryLock() {
		return nil, errors.New("FSM already started")
	}

	// Set context
	f.ctx = ctx

	// Apply options
	for _, opt := range opts {
		if err := opt(f); err != nil {
			return nil, err
		}
	}
	if f.store == nil {
		if err := fsm.InMemory()(f); err != nil {
			return nil, err
		}
	}

	// Start FSM processors
	// Start 0 deleteRecordProcessor processors
	for i := 0; i < 0; i++ {
		go f.deleteRecordProcessor()
	}
	go f.deleteRecordProcessor()
	// Start 5 deleteRepoProcessor processors
	for i := 0; i < 5; i++ {
		go f.deleteRepoProcessor()
	}
	go f.deleteRepoProcessor()
	// Start 0 doneProcessor processors
	for i := 0; i < 0; i++ {
		go f.doneProcessor()
	}
	go f.doneProcessor()
	// Start 0 errorProcessor processors
	for i := 0; i < 0; i++ {
		go f.errorProcessor()
	}
	go f.errorProcessor()

	// Resume existingtasks
	if err := f.resumeTasks(ctx); err != nil {
		return nil, err
	}
	return f, nil
}

func (f *deleteWorkspaceFSM) resumeTasks(ctx context.Context) error {
	tasks, err := f.store.Q().ListTasks(ctx)
	if err != nil {
		return err
	}
	for _, task := range tasks {
		transition, err := f.store.Q().GetLastValidTransition(ctx, task.ID)
		if err != nil {
			return err
		}

		switch DeleteWorkspaceState(transition.ToState) {
		case DeleteWorkspaceStateDeleteRecord:
			var msg deleteWorkspaceFSM_DeleteRecordParams
			if err := gob.NewDecoder(bytes.NewReader(task.Data)).Decode(&msg); err != nil {
				return err
			}
			fsm.Logger(ctx).Info("Resuming task", "id", task.ID)
			select {
			case f.deleteRecordQueue <- msg:
				return nil
			case <-ctx.Done():
				return errors.New("task submission cancelled")
			}
		case DeleteWorkspaceStateDeleteRepo:
			var msg deleteWorkspaceFSM_DeleteRepoParams
			if err := gob.NewDecoder(bytes.NewReader(task.Data)).Decode(&msg); err != nil {
				return err
			}
			fsm.Logger(ctx).Info("Resuming task", "id", task.ID)
			select {
			case f.deleteRepoQueue <- msg:
				return nil
			case <-ctx.Done():
				return errors.New("task submission cancelled")
			}
		}
	}
	return nil
}

// FSM options

func (f *deleteWorkspaceFSM) WithStore(store fsm.Store) {
	f.store = store
}

func (f *deleteWorkspaceFSM) WithContext(update func(context.Context) context.Context) {
	f.ctx = update(f.ctx)
}

func (f *deleteWorkspaceFSM) WithTransitionListener(listener fsm.TransitionListener) {
	f.onTransition = listener
}

func (f *deleteWorkspaceFSM) WithCompletionListener(listener fsm.CompletionListener) {
	f.onCompletion = listener
}

// FSM transition methods

func (f *deleteWorkspaceFSM) ToDeleteRecord(ctx context.Context, P0 WorkspaceContext) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(DeleteWorkspaceStateDeleteRecord)
	msg := deleteWorkspaceFSM_DeleteRecordParams{ID: id, P0: P0}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(
		ctx,
		int64(id),
		string(fromState),
		string(toState),
		buf.Bytes()); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.deleteRecordQueue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *deleteWorkspaceFSM) ToDeleteRepo(ctx context.Context, P0 WorkspaceContext, P1 WorkspaceID) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(DeleteWorkspaceStateDeleteRepo)
	msg := deleteWorkspaceFSM_DeleteRepoParams{ID: id, P0: P0, P1: P1}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(
		ctx,
		int64(id),
		string(fromState),
		string(toState),
		buf.Bytes()); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.deleteRepoQueue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *deleteWorkspaceFSM) ToDone(ctx context.Context) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(DeleteWorkspaceStateDone)
	msg := deleteWorkspaceFSM_DoneParams{ID: id}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(
		ctx,
		int64(id),
		string(fromState),
		string(toState),
		buf.Bytes()); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.doneQueue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *deleteWorkspaceFSM) ToError(ctx context.Context) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(DeleteWorkspaceStateError)
	msg := deleteWorkspaceFSM_ErrorParams{ID: id}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(
		ctx,
		int64(id),
		string(fromState),
		string(toState),
		buf.Bytes()); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.errorQueue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *deleteWorkspaceFSM) deleteRecordProcessor() {
	ctx := fsm.PutState(f.ctx, fsm.State(DeleteWorkspaceStateDeleteRecord))
	for msg := range f.deleteRecordQueue {
		ctx = fsm.PutAttempt(ctx, msg.Attempt)
		fsm.Logger(ctx).Debug("Processing message", "id", msg.ID, "state", DeleteWorkspaceStateDeleteRecord)
		if err := f.deleteRecordState(fsm.PutTaskID(ctx, msg.ID), f, msg.P0); err != nil {
			go func() {
				fsm.Logger(ctx).Debug("Processing error", "id", msg.ID, "attempt", msg.Attempt, "state", DeleteWorkspaceStateDeleteRecord, "error", err)
				msg.Attempt++
				select {
				case f.deleteRecordQueue <- msg:
				case <-ctx.Done():
				}
			}()
		}
	}
}

func (f *deleteWorkspaceFSM) deleteRepoProcessor() {
	ctx := fsm.PutState(f.ctx, fsm.State(DeleteWorkspaceStateDeleteRepo))
	for msg := range f.deleteRepoQueue {
		ctx = fsm.PutAttempt(ctx, msg.Attempt)
		fsm.Logger(ctx).Debug("Processing message", "id", msg.ID, "state", DeleteWorkspaceStateDeleteRepo)
		if err := f.deleteRepoState(fsm.PutTaskID(ctx, msg.ID), f, msg.P0, msg.P1); err != nil {
			go func() {
				fsm.Logger(ctx).Debug("Processing error", "id", msg.ID, "attempt", msg.Attempt, "state", DeleteWorkspaceStateDeleteRepo, "error", err)
				msg.Attempt++
				select {
				case f.deleteRepoQueue <- msg:
				case <-ctx.Done():
				}
			}()
		}
	}
}

func (f *deleteWorkspaceFSM) doneProcessor() {
	ctx := fsm.PutState(f.ctx, fsm.State(DeleteWorkspaceStateDone))
	for msg := range f.doneQueue {
		if f.onCompletion != nil {
			f.onCompletion(ctx, msg.ID, fsm.State(DeleteWorkspaceStateDone))
		}
	}
}

func (f *deleteWorkspaceFSM) errorProcessor() {
	ctx := fsm.PutState(f.ctx, fsm.State(DeleteWorkspaceStateError))
	for msg := range f.errorQueue {
		if f.onCompletion != nil {
			f.onCompletion(ctx, msg.ID, fsm.State(DeleteWorkspaceStateError))
		}
	}
}

// Submit FSM tasks

func (f *deleteWorkspaceFSM) Submit(ctx context.Context, P0 WorkspaceContext) (fsm.TaskID, error) {
	msg := deleteWorkspaceFSM_DeleteRecordParams{P0: P0}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return 0, err
	}

	task, err := f.store.Q().CreateTask(ctx, buf.Bytes())
	if err != nil {
		return 0, err
	}
	msg.ID = fsm.TaskID(task.ID)

	select {
	case f.deleteRecordQueue <- msg:
		return msg.ID, nil
	case <-ctx.Done():
		return 0, errors.New("task submission cancelled")
	}
}
