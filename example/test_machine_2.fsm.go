// Generated by fsmgen. DO NOT EDIT.
package example

import (
	"bytes"
	"context"
	"encoding/gob"
	"errors"
	"fmt"
	fsm "github.com/egoodhall/fsm"
	sqlc "github.com/egoodhall/fsm/gen/sqlc"
	"sync"
	"time"
)

const (
	TestMachine2StateState1 fsm.State = "State1"
	TestMachine2StateState2 fsm.State = "State2"
	TestMachine2StateDone   fsm.State = "Done"
)

type TestMachine2FSM interface {
	fsm.SupportsOptions
	Submit(ctx context.Context, int int) (fsm.TaskID, error)
}

func NewTestMachine2FSMBuilder() TestMachine2FSMBuilder_State1Stage {
	return new(testMachine2FSM)
}

type TestMachine2State1Transitions interface {
	ToState2(context.Context, int) error
}

type TestMachine2State2Transitions interface {
	ToDone(context.Context) error
}

type TestMachine2FSMBuilder_State1Stage interface {
	FromState1(func(context.Context, TestMachine2State1Transitions, int) error) TestMachine2FSMBuilder_State2Stage
}

type TestMachine2FSMBuilder_State2Stage interface {
	FromState2(func(context.Context, TestMachine2State2Transitions, int) error) TestMachine2FSMBuilder__FinalStage
}

type TestMachine2FSMBuilder_DoneStage interface {
	FromDone(func(context.Context) error) TestMachine2FSMBuilder__FinalStage
}

type TestMachine2FSMBuilder__FinalStage interface {
	BuildAndStart(context.Context, ...fsm.Option) (TestMachine2FSM, error)
}

// FSM type checks
var _ TestMachine2FSM = new(testMachine2FSM)
var _ fsm.SupportsOptions = new(testMachine2FSM)
var _ TestMachine2FSMBuilder_State1Stage = new(testMachine2FSM)
var _ TestMachine2FSMBuilder_State2Stage = new(testMachine2FSM)
var _ TestMachine2FSMBuilder__FinalStage = new(testMachine2FSM)
var _ TestMachine2State1Transitions = new(testMachine2FSM)
var _ TestMachine2State2Transitions = new(testMachine2FSM)

// TestMachine2FSM implementation
type testMachine2FSM_State1Params struct {
	ID      fsm.TaskID
	Attempt int
	P0      int
}

type testMachine2FSM_State2Params struct {
	ID      fsm.TaskID
	Attempt int
	P0      int
}

type testMachine2FSM_DoneParams struct {
	ID      fsm.TaskID
	Attempt int
}

type testMachine2FSM struct {
	lock sync.Mutex
	ctx  context.Context

	// Configuration options
	store        fsm.Store
	onTransition fsm.TransitionListener
	onCompletion fsm.CompletionListener
	backoff      fsm.Backoff

	// FSM state transitions
	state1State func(context.Context, TestMachine2State1Transitions, int) error
	state2State func(context.Context, TestMachine2State2Transitions, int) error

	// FSM queues
	state1Queue chan testMachine2FSM_State1Params
	state2Queue chan testMachine2FSM_State2Params
	doneQueue   chan testMachine2FSM_DoneParams
}

// FSM builder methods

func (f *testMachine2FSM) FromState1(fn func(context.Context, TestMachine2State1Transitions, int) error) TestMachine2FSMBuilder_State2Stage {
	f.state1State = fn
	return f
}

func (f *testMachine2FSM) FromState2(fn func(context.Context, TestMachine2State2Transitions, int) error) TestMachine2FSMBuilder__FinalStage {
	f.state2State = fn
	return f
}

func (f *testMachine2FSM) BuildAndStart(ctx context.Context, opts ...fsm.Option) (TestMachine2FSM, error) {
	// Check if FSM is already started
	if !f.lock.TryLock() {
		return nil, errors.New("FSM already started")
	}

	// Set context
	f.ctx = ctx

	// Initialize state queues
	f.state1Queue = make(chan testMachine2FSM_State1Params, 5)
	f.state2Queue = make(chan testMachine2FSM_State2Params, 5)
	f.doneQueue = make(chan testMachine2FSM_DoneParams, 5)

	// Apply options
	for _, opt := range opts {
		if err := opt(f); err != nil {
			return nil, err
		}
	}
	if f.store == nil {
		if store, err := fsm.InMemory()(); err != nil {
			return nil, err
		} else {
			f.store = store
		}
	}
	if f.backoff == nil {
		f.backoff = fsm.LinearBackoff(500*time.Millisecond, 30*time.Second)
	}

	// Start FSM processors
	// Start 0 state1Processor processors
	for _ = range 0 {
		go f.state1Processor()
	}
	go f.state1Processor()
	// Start 5 state2Processor processors
	for _ = range 5 {
		go f.state2Processor()
	}
	go f.state2Processor()
	// Start 0 doneProcessor processors
	for _ = range 0 {
		go f.doneProcessor()
	}
	go f.doneProcessor()

	// Resume existingtasks
	if err := f.resumeTasks(); err != nil {
		return nil, err
	}
	return f, nil
}

func (f *testMachine2FSM) resumeTasks() error {
	tasks, err := f.store.Q().ListTasks(f.ctx)
	if err != nil {
		return err
	}
	for _, task := range tasks {
		transition, err := f.store.Q().GetLastValidTransition(f.ctx, task.ID)
		if err != nil {
			return err
		}

		switch fsm.State(transition.ToState) {
		case TestMachine2StateState1:
			var msg testMachine2FSM_State1Params
			if err := gob.NewDecoder(bytes.NewReader(task.Data)).Decode(&msg); err != nil {
				return err
			}
			fsm.Logger(f.ctx).Info("Resuming task", "id", task.ID)
			select {
			case f.state1Queue <- msg:
				return nil
			case <-f.ctx.Done():
				return errors.New("task submission cancelled")
			}
		case TestMachine2StateState2:
			var msg testMachine2FSM_State2Params
			if err := gob.NewDecoder(bytes.NewReader(task.Data)).Decode(&msg); err != nil {
				return err
			}
			fsm.Logger(f.ctx).Info("Resuming task", "id", task.ID)
			select {
			case f.state2Queue <- msg:
				return nil
			case <-f.ctx.Done():
				return errors.New("task submission cancelled")
			}
		}
	}
	return nil
}

// FSM options

func (f *testMachine2FSM) WithStore(store fsm.Store) {
	f.store = store
}

func (f *testMachine2FSM) WithContext(update func(context.Context) context.Context) {
	f.ctx = update(f.ctx)
}

func (f *testMachine2FSM) WithTransitionListener(listener fsm.TransitionListener) {
	f.onTransition = listener
}

func (f *testMachine2FSM) WithCompletionListener(listener fsm.CompletionListener) {
	f.onCompletion = listener
}

func (f *testMachine2FSM) WithBackoff(backoff fsm.Backoff) {
	f.backoff = backoff
}

// FSM transition methods

func (f *testMachine2FSM) ToState1(ctx context.Context, P0 int) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(TestMachine2StateState1)
	msg := testMachine2FSM_State1Params{ID: id, P0: P0}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(ctx, sqlc.RecordTransitionParams{
		TaskID:    int64(id),
		Attempt:   int64(fsm.GetAttempt(ctx)),
		FromState: string(fromState),
		ToState:   string(toState),
		Data:      buf.Bytes(),
	}); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.state1Queue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *testMachine2FSM) ToState2(ctx context.Context, P0 int) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(TestMachine2StateState2)
	msg := testMachine2FSM_State2Params{ID: id, P0: P0}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(ctx, sqlc.RecordTransitionParams{
		TaskID:    int64(id),
		Attempt:   int64(fsm.GetAttempt(ctx)),
		FromState: string(fromState),
		ToState:   string(toState),
		Data:      buf.Bytes(),
	}); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.state2Queue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *testMachine2FSM) ToDone(ctx context.Context) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(TestMachine2StateDone)
	msg := testMachine2FSM_DoneParams{ID: id}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(ctx, sqlc.RecordTransitionParams{
		TaskID:    int64(id),
		Attempt:   int64(fsm.GetAttempt(ctx)),
		FromState: string(fromState),
		ToState:   string(toState),
		Data:      buf.Bytes(),
	}); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.doneQueue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *testMachine2FSM) state1Processor() {
	ctx := fsm.PutState(f.ctx, fsm.State(TestMachine2StateState1))
	for msg := range f.state1Queue {
		ctx2 := fsm.PutAttempt(ctx, msg.Attempt)
		fsm.Logger(ctx2).Debug("Processing message", "id", msg.ID, "attempt", msg.Attempt, "state", TestMachine2StateState1)
		if err := f.state1State(fsm.PutTaskID(ctx2, msg.ID), f, msg.P0); err != nil {
			msg.Attempt++
			delay := f.backoff(msg.Attempt)
			fsm.Logger(ctx).Debug("Processing error", "id", msg.ID, "attempt", msg.Attempt, "delay", delay, "state", TestMachine2StateState1, "error", err)
			if err := f.store.Q().RecordTransition(ctx2, sqlc.RecordTransitionParams{
				TaskID:    int64(msg.ID),
				Attempt:   int64(msg.Attempt),
				FromState: string(TestMachine2StateState1),
				ToState:   string(fsm.StateError),
				Data:      []byte(err.Error()),
			}); err != nil {
				fsm.Logger(ctx).Debug("Failed to record transition", "id", msg.ID, "attempt", msg.Attempt, "delay", delay, "state", TestMachine2StateState1, "error", err)
			}

			go func() {
				<-time.After(delay)
				select {
				case f.state1Queue <- msg:
				case <-ctx.Done():
				}
			}()
		}
	}
}

func (f *testMachine2FSM) state2Processor() {
	ctx := fsm.PutState(f.ctx, fsm.State(TestMachine2StateState2))
	for msg := range f.state2Queue {
		ctx2 := fsm.PutAttempt(ctx, msg.Attempt)
		fsm.Logger(ctx2).Debug("Processing message", "id", msg.ID, "attempt", msg.Attempt, "state", TestMachine2StateState2)
		if err := f.state2State(fsm.PutTaskID(ctx2, msg.ID), f, msg.P0); err != nil {
			msg.Attempt++
			delay := f.backoff(msg.Attempt)
			fsm.Logger(ctx).Debug("Processing error", "id", msg.ID, "attempt", msg.Attempt, "delay", delay, "state", TestMachine2StateState2, "error", err)
			if err := f.store.Q().RecordTransition(ctx2, sqlc.RecordTransitionParams{
				TaskID:    int64(msg.ID),
				Attempt:   int64(msg.Attempt),
				FromState: string(TestMachine2StateState2),
				ToState:   string(fsm.StateError),
				Data:      []byte(err.Error()),
			}); err != nil {
				fsm.Logger(ctx).Debug("Failed to record transition", "id", msg.ID, "attempt", msg.Attempt, "delay", delay, "state", TestMachine2StateState2, "error", err)
			}

			go func() {
				<-time.After(delay)
				select {
				case f.state2Queue <- msg:
				case <-ctx.Done():
				}
			}()
		}
	}
}

func (f *testMachine2FSM) doneProcessor() {
	ctx := fsm.PutState(f.ctx, fsm.State(TestMachine2StateDone))
	for msg := range f.doneQueue {
		if f.onCompletion != nil {
			f.onCompletion(ctx, msg.ID, fsm.State(TestMachine2StateDone))
		}
	}
}

// Submit FSM tasks

func (f *testMachine2FSM) Submit(ctx context.Context, P0 int) (fsm.TaskID, error) {
	msg := testMachine2FSM_State1Params{P0: P0}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return 0, err
	}

	task, err := f.store.Q().CreateTask(ctx, buf.Bytes())
	if err != nil {
		return 0, err
	}
	msg.ID = fsm.TaskID(task.ID)

	select {
	case f.state1Queue <- msg:
		return msg.ID, nil
	case <-ctx.Done():
		return 0, errors.New("task submission cancelled")
	}
}
