// Generated by fsmgen. DO NOT EDIT.
package example

import (
	"bytes"
	"context"
	"encoding/gob"
	"errors"
	"fmt"
	fsm "github.com/egoodhall/fsm"
	"sync"
)

type CreateWorkspaceState fsm.State

const (
	CreateWorkspaceStateCreateRecord CreateWorkspaceState = "CreateRecord"
	CreateWorkspaceStateCloneRepo    CreateWorkspaceState = "CloneRepo"
	CreateWorkspaceStateDone         CreateWorkspaceState = "Done"
	CreateWorkspaceStateError        CreateWorkspaceState = "Error"
)

type CreateWorkspaceFSM interface {
	fsm.SupportsOptions
	Submit(ctx context.Context, WorkspaceContext WorkspaceContext) (fsm.TaskID, error)
}

func NewCreateWorkspaceFSMBuilder() CreateWorkspaceFSMBuilder_CreateRecordStage {
	return new(createWorkspaceFSM)
}

type CreateRecordTransitions interface {
	ToCloneRepo(context.Context, WorkspaceContext, WorkspaceID) error
	ToError(context.Context) error
}

type CloneRepoTransitions interface {
	ToDone(context.Context) error
	ToError(context.Context) error
}

type CreateWorkspaceFSMBuilder_CreateRecordStage interface {
	CreateRecordState(func(context.Context, CreateRecordTransitions, WorkspaceContext) error) CreateWorkspaceFSMBuilder_CloneRepoStage
}

type CreateWorkspaceFSMBuilder_CloneRepoStage interface {
	CloneRepoState(func(context.Context, CloneRepoTransitions, WorkspaceContext, WorkspaceID) error) CreateWorkspaceFSMBuilder__FinalStage
}

type CreateWorkspaceFSMBuilder_DoneStage interface {
	DoneState(func(context.Context) error) CreateWorkspaceFSMBuilder__FinalStage
}

type CreateWorkspaceFSMBuilder_ErrorStage interface {
	ErrorState(func(context.Context) error) CreateWorkspaceFSMBuilder__FinalStage
}

type CreateWorkspaceFSMBuilder__FinalStage interface {
	BuildAndStart(context.Context, ...fsm.Option) (CreateWorkspaceFSM, error)
}

// FSM type checks
var _ CreateWorkspaceFSM = new(createWorkspaceFSM)
var _ fsm.SupportsOptions = new(createWorkspaceFSM)
var _ CreateWorkspaceFSMBuilder_CreateRecordStage = new(createWorkspaceFSM)
var _ CreateWorkspaceFSMBuilder_CloneRepoStage = new(createWorkspaceFSM)
var _ CreateWorkspaceFSMBuilder__FinalStage = new(createWorkspaceFSM)
var _ CreateRecordTransitions = new(createWorkspaceFSM)
var _ CloneRepoTransitions = new(createWorkspaceFSM)

// CreateWorkspaceFSM implementation
type createWorkspaceFSM_CreateRecordParams struct {
	ID      fsm.TaskID
	Attempt int
	P0      WorkspaceContext
}

type createWorkspaceFSM_CloneRepoParams struct {
	ID      fsm.TaskID
	Attempt int
	P0      WorkspaceContext
	P1      WorkspaceID
}

type createWorkspaceFSM_DoneParams struct {
	ID      fsm.TaskID
	Attempt int
}

type createWorkspaceFSM_ErrorParams struct {
	ID      fsm.TaskID
	Attempt int
}

type createWorkspaceFSM struct {
	lock sync.Mutex
	ctx  context.Context

	// Configuration options
	store        fsm.Store
	onTransition fsm.TransitionListener
	onCompletion fsm.CompletionListener

	// FSM state transitions
	createRecordState func(context.Context, CreateRecordTransitions, WorkspaceContext) error
	cloneRepoState    func(context.Context, CloneRepoTransitions, WorkspaceContext, WorkspaceID) error

	// FSM queues
	createRecordQueue chan createWorkspaceFSM_CreateRecordParams
	cloneRepoQueue    chan createWorkspaceFSM_CloneRepoParams
	doneQueue         chan createWorkspaceFSM_DoneParams
	errorQueue        chan createWorkspaceFSM_ErrorParams
}

// FSM builder methods

func (f *createWorkspaceFSM) CreateRecordState(fn func(context.Context, CreateRecordTransitions, WorkspaceContext) error) CreateWorkspaceFSMBuilder_CloneRepoStage {
	f.createRecordQueue = make(chan createWorkspaceFSM_CreateRecordParams, 0)
	f.createRecordState = fn
	return f
}

func (f *createWorkspaceFSM) CloneRepoState(fn func(context.Context, CloneRepoTransitions, WorkspaceContext, WorkspaceID) error) CreateWorkspaceFSMBuilder__FinalStage {
	f.cloneRepoQueue = make(chan createWorkspaceFSM_CloneRepoParams, 0)
	f.cloneRepoState = fn
	return f
}

func (f *createWorkspaceFSM) BuildAndStart(ctx context.Context, opts ...fsm.Option) (CreateWorkspaceFSM, error) {
	// Check if FSM is already started
	if !f.lock.TryLock() {
		return nil, errors.New("FSM already started")
	}

	// Set context
	f.ctx = ctx

	// Apply options
	for _, opt := range opts {
		if err := opt(f); err != nil {
			return nil, err
		}
	}
	if f.store == nil {
		if err := fsm.InMemory()(f); err != nil {
			return nil, err
		}
	}

	// Start FSM processors
	// Start 0 createRecordProcessor processors
	for i := 0; i < 0; i++ {
		go f.createRecordProcessor()
	}
	go f.createRecordProcessor()
	// Start 5 cloneRepoProcessor processors
	for i := 0; i < 5; i++ {
		go f.cloneRepoProcessor()
	}
	go f.cloneRepoProcessor()
	// Start 0 doneProcessor processors
	for i := 0; i < 0; i++ {
		go f.doneProcessor()
	}
	go f.doneProcessor()
	// Start 0 errorProcessor processors
	for i := 0; i < 0; i++ {
		go f.errorProcessor()
	}
	go f.errorProcessor()

	// Resume existingtasks
	if err := f.resumeTasks(ctx); err != nil {
		return nil, err
	}
	return f, nil
}

func (f *createWorkspaceFSM) resumeTasks(ctx context.Context) error {
	tasks, err := f.store.Q().ListTasks(ctx)
	if err != nil {
		return err
	}
	for _, task := range tasks {
		transition, err := f.store.Q().GetLastValidTransition(ctx, task.ID)
		if err != nil {
			return err
		}

		switch CreateWorkspaceState(transition.ToState) {
		case CreateWorkspaceStateCreateRecord:
			var msg createWorkspaceFSM_CreateRecordParams
			if err := gob.NewDecoder(bytes.NewReader(task.Data)).Decode(&msg); err != nil {
				return err
			}
			fsm.Logger(ctx).Info("Resuming task", "id", task.ID)
			select {
			case f.createRecordQueue <- msg:
				return nil
			case <-ctx.Done():
				return errors.New("task submission cancelled")
			}
		case CreateWorkspaceStateCloneRepo:
			var msg createWorkspaceFSM_CloneRepoParams
			if err := gob.NewDecoder(bytes.NewReader(task.Data)).Decode(&msg); err != nil {
				return err
			}
			fsm.Logger(ctx).Info("Resuming task", "id", task.ID)
			select {
			case f.cloneRepoQueue <- msg:
				return nil
			case <-ctx.Done():
				return errors.New("task submission cancelled")
			}
		}
	}
	return nil
}

// FSM options

func (f *createWorkspaceFSM) WithStore(store fsm.Store) {
	f.store = store
}

func (f *createWorkspaceFSM) WithContext(update func(context.Context) context.Context) {
	f.ctx = update(f.ctx)
}

func (f *createWorkspaceFSM) WithTransitionListener(listener fsm.TransitionListener) {
	f.onTransition = listener
}

func (f *createWorkspaceFSM) WithCompletionListener(listener fsm.CompletionListener) {
	f.onCompletion = listener
}

// FSM transition methods

func (f *createWorkspaceFSM) ToCreateRecord(ctx context.Context, P0 WorkspaceContext) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(CreateWorkspaceStateCreateRecord)
	msg := createWorkspaceFSM_CreateRecordParams{ID: id, P0: P0}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(
		ctx,
		int64(id),
		string(fromState),
		string(toState),
		buf.Bytes()); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.createRecordQueue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *createWorkspaceFSM) ToCloneRepo(ctx context.Context, P0 WorkspaceContext, P1 WorkspaceID) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(CreateWorkspaceStateCloneRepo)
	msg := createWorkspaceFSM_CloneRepoParams{ID: id, P0: P0, P1: P1}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(
		ctx,
		int64(id),
		string(fromState),
		string(toState),
		buf.Bytes()); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.cloneRepoQueue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *createWorkspaceFSM) ToDone(ctx context.Context) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(CreateWorkspaceStateDone)
	msg := createWorkspaceFSM_DoneParams{ID: id}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(
		ctx,
		int64(id),
		string(fromState),
		string(toState),
		buf.Bytes()); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.doneQueue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *createWorkspaceFSM) ToError(ctx context.Context) error {
	id := fsm.GetTaskID(ctx)
	fromState := fsm.GetState(ctx)
	toState := fsm.State(CreateWorkspaceStateError)
	msg := createWorkspaceFSM_ErrorParams{ID: id}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return err
	}

	if err := f.store.Q().RecordTransition(
		ctx,
		int64(id),
		string(fromState),
		string(toState),
		buf.Bytes()); err != nil {
		return err
	}
	fsm.Logger(ctx).Debug("Transitioned state", "id", id, "from", fromState, "to", toState)
	if f.onTransition != nil {
		f.onTransition(ctx, msg.ID, fromState, toState)
	}

	select {
	case f.errorQueue <- msg:
		return nil
	case <-ctx.Done():
		return fmt.Errorf("task submission cancelled: id = %d", id)
	}
}

func (f *createWorkspaceFSM) createRecordProcessor() {
	ctx := fsm.PutState(f.ctx, fsm.State(CreateWorkspaceStateCreateRecord))
	for msg := range f.createRecordQueue {
		ctx = fsm.PutAttempt(ctx, msg.Attempt)
		fsm.Logger(ctx).Debug("Processing message", "id", msg.ID, "state", CreateWorkspaceStateCreateRecord)
		if err := f.createRecordState(fsm.PutTaskID(ctx, msg.ID), f, msg.P0); err != nil {
			go func() {
				fsm.Logger(ctx).Debug("Processing error", "id", msg.ID, "attempt", msg.Attempt, "state", CreateWorkspaceStateCreateRecord, "error", err)
				msg.Attempt++
				select {
				case f.createRecordQueue <- msg:
				case <-ctx.Done():
				}
			}()
		}
	}
}

func (f *createWorkspaceFSM) cloneRepoProcessor() {
	ctx := fsm.PutState(f.ctx, fsm.State(CreateWorkspaceStateCloneRepo))
	for msg := range f.cloneRepoQueue {
		ctx = fsm.PutAttempt(ctx, msg.Attempt)
		fsm.Logger(ctx).Debug("Processing message", "id", msg.ID, "state", CreateWorkspaceStateCloneRepo)
		if err := f.cloneRepoState(fsm.PutTaskID(ctx, msg.ID), f, msg.P0, msg.P1); err != nil {
			go func() {
				fsm.Logger(ctx).Debug("Processing error", "id", msg.ID, "attempt", msg.Attempt, "state", CreateWorkspaceStateCloneRepo, "error", err)
				msg.Attempt++
				select {
				case f.cloneRepoQueue <- msg:
				case <-ctx.Done():
				}
			}()
		}
	}
}

func (f *createWorkspaceFSM) doneProcessor() {
	ctx := fsm.PutState(f.ctx, fsm.State(CreateWorkspaceStateDone))
	for msg := range f.doneQueue {
		if f.onCompletion != nil {
			f.onCompletion(ctx, msg.ID, fsm.State(CreateWorkspaceStateDone))
		}
	}
}

func (f *createWorkspaceFSM) errorProcessor() {
	ctx := fsm.PutState(f.ctx, fsm.State(CreateWorkspaceStateError))
	for msg := range f.errorQueue {
		if f.onCompletion != nil {
			f.onCompletion(ctx, msg.ID, fsm.State(CreateWorkspaceStateError))
		}
	}
}

// Submit FSM tasks

func (f *createWorkspaceFSM) Submit(ctx context.Context, P0 WorkspaceContext) (fsm.TaskID, error) {
	msg := createWorkspaceFSM_CreateRecordParams{P0: P0}

	buf := new(bytes.Buffer)
	if err := gob.NewEncoder(buf).Encode(msg); err != nil {
		return 0, err
	}

	task, err := f.store.Q().CreateTask(ctx, buf.Bytes())
	if err != nil {
		return 0, err
	}
	msg.ID = fsm.TaskID(task.ID)

	select {
	case f.createRecordQueue <- msg:
		return msg.ID, nil
	case <-ctx.Done():
		return 0, errors.New("task submission cancelled")
	}
}
